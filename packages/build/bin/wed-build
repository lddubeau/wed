#!/usr/bin/env node

"use strict";

/* global __dirname */

const path = require("path");

const { ArgumentParser } = require("argparse");
const webpack = require("webpack");
const CopyWebpackPlugin = require("copy-webpack-plugin");

const { NormalModuleReplacementPlugin } = webpack;

const parser = new ArgumentParser({
  addHelp: true,
  description: "Build a custom wed pack.",
});

parser.addArgument("conf", {
  description: "The configuration to use.",
});

const { conf } = parser.parseArgs();

// eslint-disable-next-line import/no-dynamic-require
const wedConfig = require(path.resolve(conf));

// eslint-disable-next-line prefer-const
let { outDir, wedDir, entry, nodeModules } = wedConfig;

if (!wedDir) {
  wedDir = path.dirname(require.resolve("@wedxml/core/package.json"));
}

if (!nodeModules) {
  nodeModules = path.join(wedDir, "node_modules");
}

// A path to the modules which are siblings of @wedxml/core
const siblings = path.dirname(path.dirname(wedDir));

const wedBuildDir = path.join(wedDir, "dev", "lib");

const externals = {};

//
// The decision between what should remain "external" and what should be
// included in the bundle is a bit arbitrary.
//
// For each library, we must ask, is it going to be a problem, if the library is
// part of the bundle and used in code that co-exists with wed? A good example
// is jQuery. Mixing multiple jQuery instances on the same page is *doable* but
// it can have some undesirable side-effects. So we keep it external.
//
// On the other hand there are libraries that are mainly computational utilities
// like "merge-options" where it does not matter whether the other frameworks
// running on the same page use different versions.
//
// In all cases, there may be duplication/size considerations but these are
// different from context to context, and this is where different usages call
// for custom builds.
//
["jquery",
 "bootstrap",
 "inversify",
 "log4javascript",
 "font-awesome",
 "bootbox",
 "typeahead",
 "bloodhound",
 "interactjs",
 "bluebird",
 "bootstrap-notify",
 "dexie",
].forEach((name) => {
  externals[name] = name;
});

const config = {
  mode: "production",
  resolve: {
    modules: [wedBuildDir, nodeModules, siblings],
    alias: {
      "rangy-textrange": "rangy/lib/rangy-textrange",
    },
  },
  entry: {
    // We have to use the test entry point to build our bundle.
    wed: entry,
  },
  module: {
    rules: [{
      test: /\.js$/,
      use: ["source-map-loader"],
      enforce: "pre",
    }],
  },
  externals,
  devtool: "source-map",
  output: {
    path: path.join(path.resolve(outDir), "lib/"),
    filename: "[name].js",
    sourceMapFilename: "[name].map.js",
    library: "wed",
    libraryTarget: "amd",
  },
  performance: {
    assetFilter(assetFilename) {
      return assetFilename.endsWith(".js");
    },
  },
  plugins: [
    // This causes webpack to load wed/glue/rangy-glue whenever rangy is
    // required. Except that in rangy-glue.js when rangy is required, rangy is
    // loaded.
    new NormalModuleReplacementPlugin(/^rangy$/, (resource) => {
      if (resource.contextInfo.issuer !==
          path.join(wedBuildDir, "wed/glue/rangy-glue.js")) {
        resource.request = "wed/glue/rangy-glue";
      }
    }),
    new CopyWebpackPlugin([
      "wed/{glue,patches,polyfills,modes}/**/*",
      "../kitchen-sink.html", "kitchen-sink.js", "../doc/**/*",
      "global-config.js", "wed/**/*.css",
      "wed/less-inc/**/*"].map(name => ({
        // Using an object with a "glob" field forces CopyWebpackPlugin to treat
        // all patterns as globs and simplifies the logic a bit. Otherwise, we'd
        // have to have a "to" field to switch where we put the results of some
        // copies.
        from: {
          glob: name,
        },
        context: wedBuildDir,
      }))),
  ],
};

webpack(config, (err, stats) => {
  if (err) {
    console.error(err.stack || err);
    if (err.details) {
      console.error(err.details);
    }
    return;
  }

  console.log(stats.toString({
    assets: false,
    colors: true,
  }));

  if (stats.hasErrors()) {
    process.exit(1);
  }
});
