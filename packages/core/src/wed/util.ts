/**
 * Various utilities for wed.
 * @author Louis-Dominique Dubeau
 * @license MPL 2.0
 * @copyright Mangalam Research Center for Buddhist Languages
 */

/**
 * Calculates the distance on the basis of two deltas. This would typically be
 * called with the difference of X coordinates and the difference of Y
 * coordinates.
 *
 * @param delta1 The first delta.
 *
 * @param delta2 The second delta.
 *
 * @returns The distance.
 */
export function distFromDeltas(delta1: number, delta2: number): number {
  return Math.sqrt(delta1 * delta1 + delta2 * delta2);
}

/**
 * Measures the distance of a point from a rectangle. If the point is in the
 * rectangle or touches it, the distance is 0. In the nomenclature below, left
 * and right are on the X axis and top and bottom on the Y axis.
 *
 * @param x The x coordinate of the point.
 *
 * @param y The y coordinate of the point.
 *
 * @param left The left coordinate of the rectangle.
 *
 * @param top The top coordinate of the rectangle.
 *
 * @param right The right coordinate of the rectangle.
 *
 * @param bottom The bottom coordinate of the rectangle.
 *
 * @returns The distance.
 */
export function distFromRect(x: number, y: number, left: number, top: number,
                             right: number, bottom: number): number {
  const topDelta = y - top;
  const leftDelta = x - left;
  const bottomDelta = y - bottom;
  const rightDelta = x - right;

  const above = topDelta < 0;
  const below = bottomDelta > 0;
  // Neologism used to avoid conflict with left above.
  const lefter = leftDelta < 0;
  const righter = rightDelta > 0;

  const deltaX = lefter ? leftDelta : (righter ? rightDelta : 0);
  const deltaY = above ? topDelta : (below ? bottomDelta : 0);

  return distFromDeltas(deltaX, deltaY);
}

/**
 * Measures the absolute horizontal and vertical distances of a point from a
 * rectangle. If the point is in the rectangle or touches it, the distance is
 * 0. In the nomenclature below, left and right are on the X axis and top and
 * bottom on the Y axis.
 *
 * @param x The x coordinate of the point.
 *
 * @param y The y coordinate of the point.
 *
 * @param left The left coordinate of the rectangle.
 *
 * @param top The top coordinate of the rectangle.
 *
 * @param right The right coordinate of the rectangle.
 *
 * @param bottom The bottom coordinate of the rectangle.
 *
 * @returns The distance.
 */
export function distsFromRect(x: number, y: number, left: number, top: number,
                              right: number,
                              bottom: number): { x: number; y: number } {
  const topDelta = y - top;
  const leftDelta = x - left;
  const bottomDelta = y - bottom;
  const rightDelta = x - right;

  const above = topDelta < 0;
  const below = bottomDelta > 0;
  // Neologism used to avoid conflict with left above.
  const lefter = leftDelta < 0;
  const righter = rightDelta > 0;

  const deltaX = lefter ? leftDelta : (righter ? rightDelta : 0);
  const deltaY = above ? topDelta : (below ? bottomDelta : 0);

  return { x: Math.abs(deltaX), y: Math.abs(deltaY) };
}

/**
 * Escape character in CSS class that could cause trouble in CSS
 * selectors. *This is not a general solution.* It supports enough for the needs
 * of wed.
 *
 * @param cls The class
 *
 * @returns The escaped class.
 */
export function escapeCSSClass(cls: string): string {
  // We should investigate replacing this with CSS.escape whenever the spec for
  // that function becomes stable.
  return cls.replace(/([\][\\/!"#$%&'()*+,.:;<=>?@^`{|}~])/g, "\\$1");
}

/**
 * Makes a class string for a node in wed's data tree. The string is meant to be
 * used for the corresponding node in wed's GUI tree.
 *
 * @param name The original element name.
 *
 * @param namespaces The namespaces that are known. This is used to convert
 * element name prefixes to namespace URIs.
 *
 * @returns The class string.
 */
export function classFromOriginalName(name: string,
                                      namespaces: Record<string, string>):
string {
  // Special case if we want to match all
  if (name === "*") {
    return "._real";
  }

  let [prefix, localName] = name.split(":");

  if (localName === undefined) {
    localName = prefix;
    prefix = "";
  }

  const ns = namespaces[prefix];
  if (ns === undefined) {
    throw new Error(`prefix ${prefix} is not defined in namespaces`);
  }

  // We do not output `.${escapeCSSClass(name)}` because that's redundant for a
  // search.
  return `._local_${escapeCSSClass(localName)}\
._xmlns_${escapeCSSClass(ns)}._real`;
}

let nextID = 0;

/**
 * Generates a new generic element id. This id is guaranteed to be unique for
 * the current run of wed. The ids generated by this function are meant to be
 * eventually replaced by something more permanent.
 *
 * @returns An element id.
 */
export function newGenericID(): string {
  return `WED-ID-${++nextID}`;
}

/**
 * **This function is meant to be used in debugging.** It creates a
 * ``selenium_log`` object on ``window`` which is an array that contains the
 * series of ``obj`` passed to this function. Remember that ultimately
 * ``selenium_log`` is going to be serialized by Selenium. So go easy on what
 * you put in there and be aware that Selenium may have bugs that prevent
 * serialization of certain objects.
 *
 * @param args Objects to log.
 */
/* tslint:disable:no-any no-unsafe-any */
export function seleniumLog(...args: any[]): void {
  const w = window as any;
  if (w.selenium_log === undefined) {
    w.selenium_log = [];
  }

  w.selenium_log.push.apply(w.selenium_log, args);
}

function _exceptionStackTrace(err: any): string {
  try {
    throw err;
  }
  catch (e) {
    return e.stack;
  }
}
/* tslint:enable */

/**
 * **This function is meant to be used in debugging.** Gets a stack trace. This
 * is only as cross-platform as needed for the platforms we support.
 *
 * Support for IE 9 is missing because it was designed by baboons.
 */
export function stackTrace(): string {
  const err = new Error();
  if (err.stack != null) {
    return err.stack;
  }

  // If the stack is not filled already (true of IE 10, 11) then raise an
  // exception to fill it.
  return _exceptionStackTrace(err);
}

/**
 * Convert a "pattern object" to a string that can be shown to the user. This
 * function is meant to be used for "complex" name patterns that we may get from
 * salve. Note that a "pattern object" is the result of calling ``toObject()``
 * on the pattern. The goal of this function is to convert the pattern object to
 * a string that would be interpretable by the end user.
 *
 * An explanation about how this handles namespaces and wildcard patterns is in
 * order. In a Relax NG schema the name pattern ``*`` in the compact notation is
 * equivalent to ``<anyName/>`` in the expanded notation. And ``foo:*`` is
 * equivalent to ``<nsName ns="uri_of_foo">`` where ``uri_of_foo`` is the URI
 * that has been associated with ``foo`` in the compact schema. It would be nice
 * if the function here could reuse this notation, but we cannot. Consider the
 * case where an Relax NG schema in the compact notation wants to declare a name
 * pattern which means "any name in the default namespace". In XML we express a
 * name in the default namespace currently in effect by simply not prefixing it
 * with a namespace name: whereas ``foo:bar`` is the ``bar`` element in the
 * ``foo`` namespace, ``bar`` is the ``bar`` element in the default
 * namespace. The pattern "any element in namespace foo" is represented with
 * ``foo:*``, however we cannot use ``*`` to mean "any element in the default
 * namespace", because ``*`` means "any name in any namespace whatsoever". The
 * compact notation forces the author of the schema to use a prefix for the
 * default namespace. And because of this, ``*`` means unambiguously "any
 * element in any namespace".
 *
 * So the ``*`` in the Relax NG schema becomes ``*:*`` here. "Any element in the
 * default namespace" is represented by ``*``. Thus ``foo:*`` and ``*`` can
 * stand in the same relation to one another as ``foo:bar`` and ``bar``.
 *
 * @param obj The "pattern object" to convert.
 * @param resolver The resolver to use to convert URIs to prefixes.
 * @returns The string representing the pattern.
 */
/* tslint:disable:no-any no-unsafe-any */
export function convertPatternObj(obj: any, resolver: any): string {
  // NameChoice
  if (obj.a != null && obj.b != null) {
    return `(${convertPatternObj(obj.a, resolver)}) or \
(${convertPatternObj(obj.b, resolver)})`;
  }

  let ret: string;

  // AnyName
  if (obj.pattern === "AnyName") {
    ret = "*:*";
  }
  else {
    // Name and NsName
    if (obj.ns === undefined) {
      throw new Error("unexpected undefined obj.ns");
    }

    if (obj.name !== undefined) {
      ret = resolver.unresolveName(obj.ns, obj.name);
      // Cannot unresolve, use the expanded name.
      if (ret === undefined) {
        ret = `{${obj.ns}}${obj.name}`;
      }
    }
    else {
      const ns = resolver.prefixFromURI(obj.ns);
      // If ns is undefined, we cannot resolve the URI, so we
      // display the expanded name.
      if (ns === undefined) {
        ret = `{${obj.ns}}`;
      }
      else {
        // An empty ns happens if the URI refers to the default
        // namespace.
        ret = (ns !== "") ? (`${ns}:`) : ns;
      }
      ret += "*";
    }
  }

  if (obj.except != null) {
    ret += ` except (${convertPatternObj(obj.except, resolver)})`;
  }
  return ret;
}
/* tslint:enable */

/**
 * This is required to work around a problem when extending built-in classes
 * like ``Error``. Some of the constructors for these classes return a value
 * from the constructor, which is then picked up by the constructors generated
 * by TypeScript (same with ES6 code transpiled through Babel), and this messes
 * up the inheritance chain.
 *
 * See https://github.com/Microsoft/TypeScript/issues/12123.
 */
// tslint:disable-next-line:no-any ban-types
export function fixPrototype(obj: any, parent: Function): void {
  // tslint:disable-next-line:ban-types
  const oldProto: Function = Object.getPrototypeOf !== undefined ?
    Object.getPrototypeOf(obj) : obj.__proto__;

  if (oldProto !== parent) {
    if (Object.setPrototypeOf !== undefined) {
      Object.setPrototypeOf(obj, parent.prototype);
    }
    else {
      obj.__proto__ = parent.prototype;
    }
  }
}

//  LocalWords:  Mangalam MPL Dubeau util CSS wed's unencoded URIs localName ns
//  LocalWords:  escapeCSSClass xmlns prepended nextID NG NameChoice AnyName
//  LocalWords:  convertPatternObj NsName
