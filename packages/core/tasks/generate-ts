#!/usr/bin/env node

"use strict";

const path = require("path");

const yaml = require("js-yaml");
const { compile } = require("json-schema-to-typescript");

const { fs, newer } = require("../gulptasks/util");

process.on("unhandledRejection", (err) => {
  // eslint-disable-next-line no-console
  console.log(err);
  process.exit(1);
});

function parseFile(name, data) {
  let ret;

  try {
    ret = JSON.parse(data);
  }
  // eslint-disable-next-line no-empty
  catch (ex) {}

  if (ret !== undefined) {
    return ret;
  }

  try {
    ret = yaml.safeLoad(data, {
      schema: yaml.JSON_SCHEMA,
    });
  }
  // eslint-disable-next-line no-empty
  catch (ex) {}

  if (ret !== undefined) {
    return ret;
  }

  throw new Error(`cannot parse ${name}`);
}

async function convertJSONSchemaToTS(srcPath, destBaseName) {
  if (!destBaseName) {
    destBaseName = path.basename(srcPath).replace(/(\..*?)?$/, ".d.ts");
  }

  const baseDirname = path.dirname(srcPath);

  srcPath = `src/${srcPath}`;
  const dest = path.join("build/generated/lib", baseDirname, destBaseName);
  const result = await newer(srcPath, dest);
  if (!result) {
    return undefined;
  }

  const ts = await compile(parseFile(srcPath, await fs.readFile(srcPath)));
  return fs.outputFile(dest, ts);
}

Promise.all([
  convertJSONSchemaToTS("wed/modes/generic/metadata-schema.json",
                        "metadata-as-json.d.ts"),
  convertJSONSchemaToTS("wed/wed-options-schema.yml", "wed-options.d.ts"),
  convertJSONSchemaToTS("wed/options-schema.yml", "options.d.ts"),
]);
